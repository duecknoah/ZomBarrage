<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(fnt_normal);
show_debug_message(object_get_name(object_index) + " created");

// Game gui settings
guiScale = 4;
guiAlpha = 1; // OVERALL ALPHA, when 0, no gui is shown in any category
upgradeGuiAlpha = 1;
pauseGuiAlpha = 0.5;
endGameStatsGuiAlpha = 0;
waveBarGuiAlpha = 1;
OnFireGuiAlpha = 0; // when player is on fire, this will increase
shootDelayMax[0] = 0; // stores the highest value when shootdelay[0] of player is not 0
shootDelayMax[1] = 0; // stores the highest value when shootdelay of player is not 0
// gui variables
showUpgrades = false; // show upgrade gui?
showPause = false; // show pause gui?
showWeaponPickupText = false; // show weapon pickup text?
// Cutscene
foregroundImage = noone;
foregroundImageAlpha = 0; // 1=nothing shown but foreground image, 0=foreground image not shown, everything else shown, 0-1)

// Console
consoleSurf = surface_create(750, 500); // surface used for console drawing
showConsole = false; // can be toggled in debug mode
outputConsoleString = ""; // console string of previously typed things
inputConsoleString = ""; // current typed console string
consoleHelpDB = ds_list_create(); // console help list dataBase
consoleLineOffset = 0; // 0 - n, where n is the last line in the console outputConsoleString
                       // scrolling affects this number when in the console
scr_initConsoleDB();

scr_consoleOutPrintln("Console: Type 'help' for help.");
scr_consoleOutPrintln("Press 'TAB' to close");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy consoleHelpDB ds list, free mem
if (ds_exists(consoleHelpDB, ds_type_list)) {
    ds_list_destroy(consoleHelpDB);
}

// Free console surface from mem
if (surface_exists(consoleSurf)) {
    surface_free(consoleSurf);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// gui
// Main temp Vars
var centerX = view_wport[0] / 2;
var centerY = view_hport[0] / 2;
display_set_gui_size(view_wport[0], view_hport[0]);
draw_set_alpha(guiAlpha);

//////////////////////////
// When game over, fade out game gui and fade in stats
if (global.gameOver) {
    endGameStatsGuiAlpha = 1;
}
var onFireFadeSpd = 0.01;
if (obj_player.isOnFire) {
    if (OnFireGuiAlpha &lt; 1) {
        OnFireGuiAlpha += onFireFadeSpd;
    }
}
else {
    if (OnFireGuiAlpha &gt; 0) {
        OnFireGuiAlpha -= onFireFadeSpd;
    }
}
// on Fire gui
if (OnFireGuiAlpha &gt; 0) {
    draw_sprite_ext(spr_onFireGui, 0, 0, 0, 10, 10, 0, c_white, scr_lerpOffGuiAlpha(OnFireGuiAlpha));
}

// Game gui
// Sniper rifle scope
if (obj_player.state == "Sniper Rifle scoped" || obj_player.state == "Sniper Rifle scoped shoot") {
    // draw zoomed in portion from default application surface
    var xSize = 128;
    var ySize = 128;
    var scale = 2;
    /* NOTE 1: We draw the application surface twice as the shadow tiles
     * seem to be slightly transparent for some odd reason. So
     * to counter this, we draw the application surface several
     * times to cancel out the alpha
     * NOTE 2: We have a sniperScopeLight used in obj_player's player state
     * manager (scr_PlayerStateManager()), this light follows the mouse_x and
     * mousey under the scope, giving the player a lit up view. It also allows
     * the application surface to pre-draw that area just before the below code
     * is executed, if this is not done, any area attempted to draw that isn't
     * effected by a light doesn't get drawn. Not sure why :(
     */
    for(var i = 0; i &lt; 2; i ++) {
    draw_surface_part_ext(application_surface, 
                            device_mouse_x_to_gui(0) - (xSize / 2), 
                            device_mouse_y_to_gui(0) - (ySize / 2), 
                            xSize, 
                            ySize, 
                            device_mouse_x_to_gui(0) - (xSize * scale / 2), 
                            device_mouse_y_to_gui(0) - (ySize * scale / 2), 
                            scale, 
                            scale, 
                            c_white,
                            guiAlpha);
    }
    draw_sprite_ext(spr_sniperRifleScope, 0, device_mouse_x_to_gui(0), device_mouse_y_to_gui(0), guiScale, guiScale, 0, c_white, guiAlpha);
}

// Draw WaveBar
var text = "";
var yy = sprite_get_height(spr_WaveBar) * guiScale / 2;

draw_sprite_ext(spr_WaveBar, 0, centerX, yy, guiScale, guiScale, 0, c_white, scr_lerpOffGuiAlpha(waveBarGuiAlpha));

text += "Wave " + string(global.currentWave);

if (global.delayBetweenWavesTimer &gt;= 0) {
    text += "   Next Wave: " + string(global.delayBetweenWavesTimer);
}

draw_set_halign(fa_center);
draw_set_valign(fa_middle);
draw_set_colour(c_white);
draw_set_alpha(scr_lerpOffGuiAlpha(waveBarGuiAlpha));
draw_text(centerX, yy, text);
draw_set_halign(fa_left);
draw_set_valign(fa_top);

// Draw Upgrade Bar
var text = "";
var xx = centerX / 2 - (sprite_get_width(spr_upgradeBar) * guiScale / 2);
var yy = 0;

if (scr_buttonGuiSpriteText(xx, yy, spr_upgradeBar, guiScale, "UPGRADES", c_white, scr_lerpOffGuiAlpha(upgradeGuiAlpha)) == 2
|| keyboard_check_pressed(vk_tab)) {
    // Toggle upgrades if button pressed
    if (showUpgrades) {
        showUpgrades = false;
        // Put timescale back to normal
        scr_setTimeScale(1);
        mouse_clear(mb_any);
    }
    else {
        showUpgrades = true;
        // Make global.timeScale slower when accessing upgrades (so player doesn't just die right away
        scr_setTimeScale(0.05);
        mouse_clear(mb_any); // prevent user from accidently buying something instantly
    }
}

// Draw Pause Button Bar
xx = centerX + (centerX / 2) + (sprite_get_width(spr_upgradeBar) * guiScale / 2);
yy = 0;
if (!global.gameOver) {
    if (scr_buttonGuiSpriteText(xx, yy, spr_upgradeBar, guiScale, "PAUSE", c_white, guiAlpha) == 2
    || keyboard_check_pressed(vk_escape)) {
        // Toggle pausing
        if (!showPause) {
            scr_setTimeScale(0);
            showPause = true;
        }
        else {
            scr_setTimeScale(1);
            showPause = false;
        }
    }
}

// Wave completed text
var durOfText = 3; // maximum duration to show text in seconds

if (global.waveCompleted &amp;&amp; global.delayBetweenWaves - global.delayBetweenWavesTimer &lt; durOfText) {
    draw_text(centerX, centerY, "Wave Completed!");
}

// Draw inventory GUI
scr_drawInventoryGui(0,
                    view_hport[0] - (sprite_get_height(spr_inventory) / 2 * guiScale),
                    guiScale,
                    guiAlpha);


// Draw HealthBar Gui
var hbx = centerX - ((sprite_get_width(spr_healthBar) / 2) * guiScale);
var hby = view_hport[0] - (sprite_get_height(spr_healthBar) * guiScale);
var hbHealthMaxXScale = guiScale;
var hbHealthPerc = obj_player.hp / obj_player.maxHp;
var hbHealthXScale = lerp(0, hbHealthMaxXScale, hbHealthPerc);

// Healthbar background (behind red health)
draw_sprite_ext(spr_healthBar, 2, hbx, hby, guiScale, guiScale, 0, c_white, guiAlpha);
// Healthbar health (red)
draw_sprite_ext(spr_healthBar, 1, hbx, hby, hbHealthXScale, guiScale, 0, c_white, guiAlpha);
// Healthbar frame
draw_sprite_ext(spr_healthBar, 0, hbx, hby, guiScale, guiScale, 0, c_white, guiAlpha);

// Weapon pickup text toggling
with (obj_player) {
    if (place_meeting(x, y, obj_itemWeapon)) {
        other.showWeaponPickupText = true;
    }
    else {
        other.showWeaponPickupText = false;
    }   
}
// Weapon pickup text
if (showWeaponPickupText) {
    var weaponInst;
    with (obj_player) {
        weaponInst = instance_place(x, y, obj_itemWeapon);
    }
    draw_text(view_wport[0] / 2, view_hport[0] / 2 + 256, "'E' to pickup " + weaponInst.weaponType);
}

// Looting bar
if (obj_player.state == "looting") {
    var lbx = centerX;
    var lby = centerY;
    draw_sprite_ext(spr_lootingBar, 0, lbx, lby, guiScale, guiScale, 0, c_white, guiAlpha);
    // Draw progress bar
    var lbProgressX1 = lbx - ((sprite_get_width(spr_lootingBar) / 2) * guiScale) + (7 * guiScale);
    var lbProgressY1 = lby - ((sprite_get_height(spr_lootingBar) / 2) * guiScale) + (4 * guiScale);
    var lbProgressX2 = lbx - ((sprite_get_width(spr_lootingBar) / 2) * guiScale) + (89 * guiScale);
    var lbProgressY2 = lby - ((sprite_get_height(spr_lootingBar) / 2) * guiScale) + (11 * guiScale);
    var lootPerc = 1 - (obj_player.lootTimer / obj_player.lootTime);
    
    var lbProgressX2 = lerp(lbProgressX1, lbProgressX2, lootPerc);
    
    draw_set_colour(c_yellow);
    draw_rectangle(lbProgressX1, lbProgressY1, lbProgressX2, lbProgressY2, 0);
    draw_set_colour(c_white);
}
// Looting choose gui
if (obj_player.state == "loot choose") {
    // Darken background
    draw_set_alpha(0.5);
    draw_set_colour(c_black);
    draw_rectangle(0, 0, view_wport[0], view_hport[0], 0);
    draw_set_colour(c_white); // reset
    draw_set_alpha(guiAlpha); // reset
    
    var yy = view_hport[0] / 2;
    
    // Draw current inventory GUI
    scr_drawInventoryGui(256,
                    yy,
                    guiScale,
                    guiAlpha);
    // Draw loot area gui
    scr_drawAreaLootGui(view_wport[0] / 2, 
                    yy - 64, 
                    obj_player.lootArea, 
                    guiScale, 
                    guiAlpha);
}

// Draw upgrade screen if alpha &gt; 0 and showing upgrades and not game over
if (upgradeGuiAlpha &gt; 0 &amp;&amp; showUpgrades &amp;&amp; !global.gameOver) {
    /* Things that can be upgraded:
     * - player max hp
     * - player overall shot accuracy
     * - player lootRank
     * - player lootRange
    */
    // Draw background
    var bx = centerX - (sprite_get_width(spr_upgradeBackground) * guiScale / 2);
    var by = centerY - (sprite_get_height(spr_upgradeBackground) * guiScale / 2);
    draw_sprite_ext(spr_upgradeBackground, 0, bx, by, guiScale, guiScale, 0, c_white, scr_lerpOffGuiAlpha(upgradeGuiAlpha));
    
    // Upgrade buttons
    var xx = bx;
    var yy = by;
    var yOff = sprite_get_height(spr_upgradeButton) * guiScale + 4;
   /* ex. upgrade button:
    *   if (scr_buttonGuiUpgrade(xx, yy, spr_upgradeBar, "This is a test upgrade.", 1, guiScale)) {
    *       room_restart();
    *   }
   */
   if (scr_buttonGuiUpgrade(xx, yy, 
                            "TEMP_NO_SPRITE", 
                            "Increase max health of yourself by 10#Current: " + string(obj_player.maxHp),
                            2 * obj_player.maxHp,
                            guiScale, scr_lerpOffGuiAlpha(upgradeGuiAlpha))) {
        obj_player.maxHp += 10;
        obj_player.hp = obj_player.maxHp;
   }
   yy += yOff;
   if (scr_buttonGuiUpgrade(xx, yy, 
                            "TEMP_NO_SPRITE", 
                            "Increase your lootrank.#Current: " + string(obj_player.lootRank), 
                            10 * obj_player.lootRank + 5, 
                            guiScale, scr_lerpOffGuiAlpha(upgradeGuiAlpha))) {
        obj_player.lootRank ++;
   }
   yy += yOff;
   if (scr_buttonGuiUpgrade(xx, yy, 
                           "TEMP_NO_SPRITE",
                           "Increase your average shot accuracy.#Current: +" + string((1 - obj_player.shotAcc) * 100) + "%", 
                           10 * obj_player.shotAcc + 5, 
                           guiScale, scr_lerpOffGuiAlpha(upgradeGuiAlpha))) {
        obj_player.shotAcc /= 1.5;
   }
   yy += yOff;
   if (scr_buttonGuiUpgrade(xx, yy, 
                           "TEMP_NO_SPRITE",
                           "Increase your explosive damage by 5.#Current: +" + string(obj_player.exploDmg), 
                           10 * obj_player.exploDmg + 5, 
                           guiScale, scr_lerpOffGuiAlpha(upgradeGuiAlpha))) {
        obj_player.exploDmg += 5;
   }
   yy += yOff;
   if (scr_buttonGuiUpgrade(xx, yy, 
                           "TEMP_NO_SPRITE",
                           "Increase your bullet damage by 5.#Current: +" + string(obj_player.bulletDmg), 
                           10 * obj_player.bulletDmg + 5, 
                           guiScale, scr_lerpOffGuiAlpha(upgradeGuiAlpha))) {
        obj_player.bulletDmg += 5;
   }
   yy += yOff;
}

// Pause Gui
if (pauseGuiAlpha &gt; 0 &amp;&amp; showPause) {
    // Fade in background alpha based of global.timeScale fade out speed
    var _backgroundAlpha = lerp(0, 0.5, 1 - global.timeScale);
    _backgroundAlpha -= pauseGuiAlpha;
    
    // Background col
    draw_set_colour(c_black);
    draw_set_alpha(scr_lerpOffGuiAlpha(_backgroundAlpha));
    draw_rectangle(0, 0, view_wport[0], view_hport[0], 0);
    draw_set_alpha(1);
    
    // Pause Text
    draw_set_colour(c_white);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_set_alpha(scr_lerpOffGuiAlpha(pauseGuiAlpha));
    draw_text(centerX, centerY, "PAUSED");
    draw_text(centerX, centerY + 128, "Press 'ESC' To Resume");
    draw_set_alpha(1);
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    
    // If player died during the slowdown of the global.timeScale
    // then unpause and reset the global.timeScale to 1.
    if (global.gameOver) {
        showPause = false;
        scr_setTimeScale(1);
    }
}

// End game stats gui
if (endGameStatsGuiAlpha &gt; 0) {
    var statsYTop = 128;
    
    draw_set_alpha(scr_lerpOffGuiAlpha(endGameStatsGuiAlpha));
    draw_text(centerX, statsYTop, "YOU DIED");
    statsYTop += 64;
    draw_text(centerX, statsYTop, "Total Waves survived: " + string(global.currentWave));
    
    var statsXBottom = centerX - 128;
    var statsYBottom = view_hport[0] - 256;
    
    // Back to main menu
    if (scr_buttonGuiSprite(statsXBottom, statsYBottom, spr_buttonBack, guiScale) == 2) {
        room_goto(rm_Menu);
    }
    statsXBottom += 256;
    if (scr_buttonGuiSprite(statsXBottom, statsYBottom, spr_buttonRetry, guiScale) == 2) {
        room_restart();
    }
    
    draw_set_alpha(1); // reset completly
}

// Cutscene foreground image gui
if (foregroundImageAlpha &gt; 0) {
    if (foregroundImage != noone) {
        var w = sprite_get_width(foregroundImage);
        var h = sprite_get_height(foregroundImage);
        var stretchedW = view_wport[0] / w;
        var stretchedH = view_hport[0] / h;
        
        draw_sprite_ext(foregroundImage, 0, 0, 0, stretchedW, stretchedH, 0, c_white, foregroundImageAlpha);
    }
}

// gui object text drawing
for (i = 0; i &lt; instance_number(obj_guiText); i += 1) {
        var guiText = instance_find(obj_guiText, i);
        draw_set_font(guiText.font);
        draw_set_halign(guiText.textHAlign);
        draw_set_valign(guiText.textVAlign);
        draw_set_alpha(guiText.textAlpha);
        draw_set_color(guiText.textCol);
        draw_text(guiText.textX, guiText.textY, guiText.text);
        //show_message(guiText.textAlpha);
}
// reset
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_alpha(1);
draw_set_color(c_white);
    
/*
if (keyboard_check_pressed(ord("I"))) {
    view_wport[0] = 1920;
    view_hport[0] = 1080;
    window_set_size(view_wport[0], view_hport[0]);
    window_set_colour(c_red);
}
*/

draw_set_alpha(1);

// If in debug mode, show framerate
if (debug_mode) {
    var _y = 16;
    draw_text(16, _y, "FPS real: " + string(fps_real));
    _y += 16;
    draw_text(16, _y, "view_xview: " + string(view_xview[0]));
    _y += 16;
    draw_text(16, _y, "view_yview: " + string(view_yview[0]));
    _y += 16;
    draw_text(16, _y, "view_wview: " + string(view_wview[0]));
    _y += 16;
    draw_text(16, _y, "view_hview: " + string(view_hview[0]));
    _y += 16;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Debug console

if (debug_mode) {
    // Toggle console
    if (keyboard_check_pressed(vk_anykey)) {
        if (keyboard_key == 192 || keyboard_key == 223) {
            if (showConsole) {
                showConsole = false;
            }
            else {
                showConsole = true;
            }
            if (string_length(keyboard_string) &gt; 0) {
                var tildePos = string_pos('`', keyboard_string);
                if (tildePos != -1) {
                    keyboard_string = string_delete(keyboard_string, tildePos, 1);
                }
            }
        }
    }
    
    if (showConsole) {
        // Re-create surface if it doesn't exist
        if (!surface_exists(consoleSurf)) {
            consoleSurf = surface_create(750, 500);
            exit; // prevent further code from running here
        }
        surface_set_target(consoleSurf);
        draw_clear_alpha(c_black, 0.5); // clear surface from last draw
        
        var consoleX = 0;
        var consoleY = 0;
        var showCursor = false; // show console cursor in this step?
        var cursorBlinkRate = room_speed / 2;

        if ((current_time / 10) % room_speed &lt; cursorBlinkRate) {
            showCursor = true;
        }
        
        // Scrolling in console
        if (mouse_wheel_up()) {
            // lower consoleLineOffset
            var lineCount = string_count("#", outputConsoleString);
            consoleLineOffset = clamp(consoleLineOffset - 1, 1, lineCount);
        }
        
        if (mouse_wheel_down()) {
            // raise consoleLineOffset
            var lineCount = string_count("#", outputConsoleString);
            consoleLineOffset = clamp(consoleLineOffset + 1, 1, lineCount);
        }
        
        draw_set_halign(fa_left);
        draw_set_valign(fa_top);
        draw_set_colour(c_white);
        // previous console string below where user types into console in
        
        // Offset the text by &lt;consoleLineOffset&gt; lines (affected by scrolling in console)
        var lineCount, oneLineH, totalOffset;
        lineCount = string_count("#", outputConsoleString);
        if (lineCount &gt; 0) {
            oneLineH = string_height_ext(outputConsoleString, -1, -1) / lineCount;
            totalOffset = oneLineH * consoleLineOffset; 
        }
        else {
            totalOffset = 0;
        }
        
        // Console output
        //draw_text(consoleX, consoleY - totalOffset, "###" + outputConsoleString);
        draw_text_ext(consoleX, consoleY - totalOffset, "###" + outputConsoleString, -1, surface_get_width(consoleSurf));
        // Console input
        draw_set_alpha(0.5);
        draw_set_colour(c_black);
        draw_rectangle(0, 0, surface_get_width(consoleSurf), surface_get_height(consoleSurf), 0); // clear surface from last draw
        draw_set_alpha(1);
        draw_set_colour(c_white);
        if (showCursor) {
            draw_text(consoleX, consoleY, inputConsoleString + '| ');
        }
        else {
            draw_text(consoleX, consoleY, inputConsoleString);
        }
        draw_set_halign(fa_left);
        draw_set_valign(fa_top);
        // Draw console surface
        surface_reset_target();
        draw_surface(consoleSurf, view_wport[0] / 4, 128);
        
        // Console input
        var input, isNoInput;
        input = scr_consoleGetInput();
        if (input != -1) {
            isNoInput = ds_list_empty(input);
            
            // Console function running
            // If there is input
           // if (!isNoInput) {
            // If there is a typed string
            // Execute the input
            scr_consoleRunFunc(input);
            ds_list_destroy(input); // free RAM
           // }
        }
        scr_consoleKeyFuncs();
    }
    else { // if not showing console
        keyboard_string = "";
        inputConsoleString = "";
    }
}
else { // if not in debug mode
    showConsole = false; // turn off showConsole
    /* this is done to prevent other objects in the
     * game (like obj_player) from thinking the console
     * is shown, when it can't be when not in debug_mode.
    */
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
