<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_playerCollision</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_characterP</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Player variables
event_inherited();
// Inventory //
        selectedSlot = 0;
    // Inventory Weapons
        inventory = ds_list_create();
        // Set up empty inventory
        // The inventory system works by holding a ds_map with all of the
        // weapon data of a single weapon, each ds_map / weapon is stored in
        // a different index in the players inventory ds_list
        for (var i = 0; i &lt; 6; i ++) {
            ds_list_add(inventory, scr_IdToWeapon(0)); // default / empty
        }

// State variables
    state = "default";
    for (var i = 0; i &lt; 6; i ++) {
        shootDelay[i] = 0; // delay between next available shot from weapon in slot i + 1 (slot i in array)
    }
    lootArea = noone; // area currently being looted.
    hidePlayer = false; //when true, player is not shown (nor the flashlight)
    lootXPrev = 0; // x previous, used after player is done looting to teleport player back outside of building
    lootYPrev = 0; // y previous, used after player is done looting to teleport player back outside of building
    xSpd = 0;
    ySpd = 0;
// Other
    flashLightOn = false; // used if player is holding a flashlight
    sniperScopeLight = instance_create(0, 0, obj_light); // light that lights up the crosshair / sniper scope view when ADS
    playerLight = instance_create(x, y, obj_light); // light that lights up around player very slightly.
    with (sniperScopeLight) {
        radius = 0; // make sniper scope light invisible until use
    }
    with (playerLight) {
        parent = other.id; 
        image_blend = c_dkgray / 4;
        radius = 256; 
    }
// Stats (DEFAULT VALUES, DATA IS LOADED FROM scr_loadSaveIntoGame within obj_save endstep)
    // Permanent (stats that last the whole game)
    maxHp = 35;
    points = 0; // how many points the player has, used in buying upgrades
    lootRange = 32; // range where player can loot from (using loot key)
    lootTime = 2; // time it takes (in seconds) to loot a building
    // Temporary (stats that last until a map change
    lootRank = 1; // the higher the better / more loot
    shotAcc = 0; // between 0-1, 0 being default weapon accuracy, 1 being 100% accurate
    exploDmg = 0; // additive explosive damage
    bulletDmg = 0; // additive bullet damage
    playerSpd = 1; // max speed of movement
    healSpd = 1; // how much the player heals per second
    safeHpCoolDownTime = 2;// how many seconds it takes after being hurt in order to start healing
    safeHpCoolDownTimer = safeHpCoolDownTime; 
    // Boosters (things that give stats a boost for a certain amount of time within the map)
    
    
    // Variables
    hp = maxHp;
    lootTimer = -1; // timer used for looting, goes based off lootTime
    // be smaller than 1 to fix between doors
    image_xscale = 0.85;
    image_yscale = 0.85;
    spr_index = spr_PlayerFists1;

scr_InitView();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player created lights

// Flashlight

if (flashLightOn) {
    scr_drawLightBeam(x, y, 255 / 8, c_white, rotation + 90, 140, 128); // outer beam
    scr_drawLightBeam(x, y, 255 / 8, c_white, rotation + 90, 115, 128); // middle beam
    scr_drawLightBeam(x, y, 255 / 2, c_white, rotation + 90, 90, 128); // inner beam
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Movement vars
if (global.timeScaleChanged) {
    // If global.timeScale changed, constantly update
    // acceleration until it is done changing
    xSpd *= global.timeScale;
    ySpd *= global.timeScale; 
}

var spd = playerSpd * global.timeScale; // maximum speed
var slowDown = power(0.75, global.timeScale); // speed of slowing down after stopping a movement key
var xAccel = 0.1 * global.timeScale;
var yAccel = 0.1 * global.timeScale;
var xMoved = false;
var yMoved = false;
    
rotationPrevious = rotation;

// If player is not dead and not in console
if (!isDead &amp;&amp; !obj_guiController.showConsole) {
    // if player movement isnt prevented and entity movement isnt prevented, allow player movement
    if (!global.preventPlayerControls &amp;&amp; !global.preventEntityMovement) {
        // Movement controls
        // First detect what player wants to do                                                                       
        var moveUp = false;
        var moveDown = false;
        var moveLeft = false;
        var moveRight = false;
        
        if (keyboard_check(ord("W"))) {
            moveUp = true;
        }
        if (keyboard_check(ord("S"))) {
            moveDown = true;
        }
        if (keyboard_check(ord("A"))) {
            moveLeft = true;
        }
        if (keyboard_check(ord("D"))) {
            moveRight = true;
        }
        
        // Move up
        // If not a collision
        if (!place_meeting(x, y + ySpd - yAccel, obj_collision)) {
            if (moveUp) {
                if (ySpd - yAccel &gt; -spd) {
                    ySpd -= yAccel;
                }
                yMoved = true;
            }
        }
        else {
          ySpd = 0;  
        }
        
        // Move down
        if (!place_meeting(x, y + ySpd + yAccel, obj_collision)) {
            if (moveDown) {
                if (ySpd &lt; spd) {
                    ySpd += yAccel;
                }
                yMoved = true;
            }
        }
        else {
            ySpd = 0;
        }
        
        // Finish calculating vertical movement add apply to y axis, this is done to prevent getting stuck in corner collisions
        if (!yMoved) {
            ySpd *= slowDown;
        }
        y += ySpd;
        
        // Move left
        if (!place_meeting(x + xSpd - xAccel, y, obj_collision)) {
            if (moveLeft) {
                if (xSpd + xAccel &gt; -spd) {
                    xSpd -= xAccel;
                }
                xMoved = true;
            }
        }
        else {
            xSpd = 0;
        }
        
        // Move right
        if (!place_meeting(x + xSpd + xAccel, y, obj_collision)) {
            if (moveRight) {
                if (xSpd &lt; spd) {
                    xSpd += xAccel;
                }
                xMoved = true;
            }
        }
        else {
            xSpd = 0;
        }
    }
    
    // Finish calculating horizontal movement add apply to x axis, this is done to prevent getting stuck in corner collisions
    if (!xMoved) {
        xSpd *= slowDown;
    }
    x += xSpd;
    
    // Healing over time when the player hasn't been hit after 
    // &lt;safeHpCoolDownTime&gt; seconds.
    if (isHurt) {
        // If hurt, reset timer
        safeHpCoolDownTimer = safeHpCoolDownTime;
    }
    else {
        // If no longer hurt, begin countdown until auto-healing
        if (safeHpCoolDownTimer &gt; 0) {
            safeHpCoolDownTimer -= (1 / room_speed) * global.timeScale;
        }
        else {
        // If timer is up, begin auto-healing player
            hp = clamp(hp + (healSpd / room_speed * global.timeScale), 0, maxHp);
        }
    }
    
    event_inherited(); // run entity functions
    
    // if player movement isnt prevented and entity movement isnt prevented, allow player movement
    if (!global.preventPlayerControls &amp;&amp; !global.preventEntityMovement) {
        // Action Controls
        // if not looting, allow changing states
        if (state != "looting" &amp;&amp; state != "loot choose") {
            switch(scr_WeaponToId(inventory[| selectedSlot])) {
                case 0: // fists / empty
                   if (mouse_check_button_pressed(mb_left)) {
                        // If not already animating punch / punching
                        if (img_index == 0 &amp;&amp; shootDelay[selectedSlot] &lt;= 0) {
                            var swingOtherArm = round(random(1));
                            if (swingOtherArm) {
                                spr_index = spr_PlayerFists2;
                                img_number = sprite_get_number(spr_PlayerFists2) - 1;
                            }
                            else {
                                spr_index = spr_PlayerFists1;
                                img_number = sprite_get_number(spr_PlayerFists1) - 1;
                            }
                            img_index = 1;
                            img_speed = 0.2 * global.timeScale;
                            state = "punch";
                            audio_play_sound_on(s_emit, choose(snd_woosh_1, snd_woosh_2), false, 5);
                        }
                   }
                break;
                case 1: //"Wimps Pistol"
                   if (mouse_check_button_pressed(mb_left)
                   &amp;&amp; shootDelay[selectedSlot] &lt;= 0) {
                        state = "shoot Wimps Pistol";
                   }
                   else state = "Wimps Pistol";
                break;
                case 2: //"M16"
                    if (mouse_check_button(mb_left)
                    &amp;&amp; shootDelay[selectedSlot] &lt;= 0) {
                        state = "shoot M16";
                    }
                    else state = "M16";
                break;
                case 3: //"Rocket Launcher"
                    if (mouse_check_button_pressed(mb_left)
                    &amp;&amp; shootDelay[selectedSlot] &lt;= 0) {
                        state = "shoot Rocket Launcher";
                    }
                    else state = "Rocket Launcher";
                break; 
                case 4: //"Flashlight"
                    if (mouse_check_button_pressed(mb_left)
                    &amp;&amp; shootDelay[selectedSlot] &lt;= 0) {
                        state = "toggle Flashlight";
                    }
                    else state = "Flashlight";
                break;
                case 5: //"Loot Key"
                    if (mouse_check_button_pressed(mb_left)
                    &amp;&amp; shootDelay[selectedSlot] &lt;= 0) {
                        state = "Loot Key use";
                    }
                    else state = "Loot Key";
                break;
                case 6: //"Sniper Rifle"
                    // Shoot with left click, different states if scoped or not
                    if (mouse_check_button_pressed(mb_left)) {
                        if (state == "Sniper Rifle scoped") {
                            if (shootDelay[selectedSlot] &lt;= 0) {
                                state = "Sniper Rifle scoped shoot";
                            }
                        }
                        else {
                            if (shootDelay[selectedSlot] &lt;= 0) {
                                state = "Sniper Rifle unscoped shoot";
                            }
                        }
                    }
                    // Toggle scope with right click
                    if (mouse_check_button_pressed(mb_right)) {
                        if (state == "Sniper Rifle scoped") {
                            state = "Sniper Rifle"; //"Sniper Rifle"
                            // Disable scope light and ADS
                            with (sniperScopeLight) {
                                radius = 0;
                                color = c_white;
                            }
                        }
                        else {
                            // Enable scope light and ADS
                            state = "Sniper Rifle scoped";
                            with (sniperScopeLight) {
                                radius = 128;
                                color = c_dkgray;
                            }
                        }
                    }
                break;
                case 7: //"Molotov Cocktail"
                    // If clicked and player still has more ammo
                    if (mouse_check_button_pressed(mb_left)
                    &amp;&amp; scr_WeaponAmmoOf(inventory[| selectedSlot]) &gt; 0
                    &amp;&amp; shootDelay[selectedSlot] &lt;= 0) {
                        state = "throw Molotov Cocktail";
                    }
                break;
                case 8: //"Frag Grenade"
                    // If clicked and player still has more ammo
                    if (mouse_check_button_pressed(mb_left)
                    &amp;&amp; scr_WeaponAmmoOf(inventory[| selectedSlot]) &gt; 0
                    &amp;&amp; shootDelay[selectedSlot] &lt;= 0) {
                        state = "throw Frag Grenade";
                    }
                break;
                case 9: //"Iron Sword"
                    // If clicked and not currently animating swing, allow swinging sword
                    if (mouse_check_button_pressed(mb_left) 
                    &amp;&amp; img_index == 0
                    &amp;&amp; shootDelay[selectedSlot] &lt;= 0) {
                        state = "swing Iron Sword";
                        img_index = 0.1;
                        img_speed = 0.20 * global.timeScale;
                        img_number = sprite_get_number(spr_PlayerIronSword); // total number of images in sprite (-1 because its an array, so its the element of the array)
                        shootDelay[selectedSlot] = (img_number * img_index) / room_speed;
                    }
                break;
                case 10: //"Chainsaw"
                    // If mouse pressed and is cooled-down after use, startup chainsaw blades
                    if (mouse_check_button_pressed(mb_left)
                    &amp;&amp; shootDelay[selectedSlot] &lt;= 0) {
                        state = "run Chainsaw";
                        img_index = 0;
                        img_speed = 0.5 * global.timeScale;
                        img_number = sprite_get_number(spr_PlayerChainsaw); // total number of images in sprite (-1 because its an array, so its the element of the array)
                    }
                     // If mouse released, stop chainsaw blades
                    else if (mouse_check_button_released(mb_left)) {
                        state = "Chainsaw";
                        img_index = 0;
                        img_speed = 0;
                        img_number = 0;
                    }
                break;
            }
        }
        var inventorySlotChange = false;
        // Inventory Controls
        for (var i = 1; i &lt;= 6; i ++) {
            if (keyboard_check_pressed(ord(string(i)))) {
                selectedSlot = i - 1;
                inventorySlotChange = true;
            }
        }
        
        if (mouse_wheel_up()) {
            //selectedSlot = (selectedSlot - 1) % ds_list_size(inventory);
            selectedSlot = abs(selectedSlot - 1) % 2;
            inventorySlotChange = true;
        }
        if (mouse_wheel_down()) {
            //selectedSlot = (selectedSlot + 1) % ds_list_size(inventory);
            selectedSlot = abs(selectedSlot + 1) % 2;
            inventorySlotChange = true;
        }
        
        // Reset any current state to default as inventory selected slot was changed
        if (inventorySlotChange) {
            scr_stopPlayerWeaponSound();
            // Don't allow changing states mid loot, else player gets stuck
            // in loot area!
            if (state != "looting" &amp;&amp; state != "loot choose") {
                state = "default";
            }
        }
        
        // Drop selected weapon
        if (keyboard_check_pressed(ord("Q"))) {
            if (scr_WeaponToId(inventory[| selectedSlot]) == 4) { // if holding Flashlight
                flashLightOn = false; // disable if player had flashlight on
            }
            // If holding an actual weapon
            if (scr_WeaponToId(inventory[| selectedSlot]) != 0) { // if not an empty slot
                scr_createWeapon(x, y, inventory[| selectedSlot]);
                inventory[| selectedSlot] = scr_IdToWeapon(0); // empty slot
                // Reset img state, else player cycles through animation forever
                img_number = sprite_get_number(spr_PlayerFists1) - 1;
                img_speed = 0;
                scr_stopPlayerWeaponSound();
            }
        }
    }
}

if (keyboard_check_pressed(vk_f12)) {
    scr_takeScreenshot();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Make sure player light is always on, so toggling all lights doesn't disable it
with (playerLight) {
    isOn = true;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Temp
if (mouse_check_button(mb_middle)) {
    instance_create(mouse_x, mouse_y, obj_zombie);
    hp = 1000000;
    maxHp = 1000000;
    //scr_createForce(mouse_x, mouse_y, 5, 1024, true, true);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_zombieP">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Slight Collision push to a zombie (other)
var xspd = x - xprevious;
var yspd = y - yprevious;

other.x += xspd / 5;
other.y += yspd / 5;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_itemWeapon">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Make weapon to pickup glow (outline)
with (other) {
    image_blend = c_yellow;
    showOutline = true;
    if (instance_exists(obj_env_light)) {
        depth = obj_env_light.depth - 1;
    }
}

if (keyboard_check_pressed(ord("E"))) {
    var actionTaken = scr_PlayerAddWeapon(other.weapon);
    
    switch(actionTaken) {
        case -1: // nothing happened
        break;
        case 0: // user picked up just the ammo
            with (other) {
                instance_destroy();
            } 
        break;
        case 1: // user picked up the weapon
            with (other) {
                instance_destroy();
            }  
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Free extra resources
if (ds_exists(inventory, ds_type_list)) {
    ds_list_destroy(inventory);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// If player is not dead and not in console and not preventing player controls and not preventing player movement
if (!isDead &amp;&amp; !obj_guiController.showConsole &amp;&amp; 
    global.timeScale != 0 &amp;&amp; !global.preventPlayerControls &amp;&amp; !global.preventEntityMovement) {
    if (point_distance(mouse_x, mouse_y, x, y) &gt; 10) {
        rotation = (point_direction(x, y, mouse_x, mouse_y) - 90);
    }
}

// Draw shadow
if (!hidePlayer) {
    draw_sprite_ext(spr_shadow, 0, x, y, image_xscale, image_yscale, 0, c_white, 1);
}
// Draw self
scr_PlayerStateManager();

// Draw hat
scr_drawHat(0, 0);

// If looting, don't fade out back tiles (else it will show an empty house)
if (state != "looting" &amp;&amp; state != "loot choose") {
    scr_fadeAboveTilesAt(x, y, 3);
    scr_fadeAbovePropsAt(x, y, false);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>8,8</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
