<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init all character variables
/* This initializes all variables required by an entity.
 * An entity is something that can move, gets
 * affected by forces, rotates, and can be
 * killed when their health reaches 0
*/
// Sprite replacement vars
/* We use these rather than image_index and image_speed
 * due to the actual sprites of a entity being its hitbox
 * sprite, so the number of subimages cycled when using the
 * default image_index is looped between the hitbox sprite
 * images
 * ex. hitbox sprite - 1 subimage
 *     the used sprite - 5 subimages
 */
    spr_index = sprite_index; // similiar to sprite_index
    img_index = 0; // similiar as image_index
    img_speed = 0; // similiar as image_speed
    img_number = 0; // similiar as image_number
    drawScale = 1; // basically image_xscale and image_yscale combined, this is to prevent effecting the hitbox when bobbing
// Main    
    rotation = 0; // use this rather than image_angle (that rotates the hitbox)
    rotationPrevious = rotation;
    maxHp = 10;
    hp = maxHp;
    isHurt = false; // was the entity just hurt?
    isOnFire = false; // is the entity on fire?
    isDead = false; // is the entity dead?
    hurtTime = 10; // time entity is hurt (game steps)
    hurtTimer = hurtTime; // timer used to keep track of how long entity has been hurt
    fireTime = room_speed * 2.5; // time (in game steps) that the player will be lit on fire for
    fireTimer = -1;
    interactEntity = noone; // the entity this character is interacting with (ex. chair, vehicle, etc.)

// Movement Variables
    path = noone; // no path by default
    doBackupPathFinding = false; // used for pathfinding
    xPush = 0; // push in x movement (usually when hit by another entity or force)
    yPush = 0; // push in y movement (usually when hit by another entity or force)
    pushResist = 0.8; // resistance of other forces (0=fully resistant, 1=no resistance)
    bobbing = random_range(0, 1); // a number between 0-1 where 0 is at the bottom of the bob and 1 is at the top
    isBobbingUp = true; // when true, as entity moves, the image_scale will enlarge, when false, it will shrink, giving an illusion of footsteps
// Extra
    hat = noone; // an index within spr_hat to represent the hat being worn (noone means no hat)
    
// Part systems
fireSparkEmitter = noone; // fire spark particle system (when ent is on fire, this is the particle shown)
fireLight = noone; // light that is created and parented to entity

// Sound
s_emit = audio_emitter_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy fire spark emitter and fireLight, and other dynamic mem stuff
if (fireLight != noone) {
    with (fireLight) {
        instance_destroy();
    }
}

// Destroy fire particle emitter
if (part_emitter_exists(obj_particleIndex.fireSpark, fireSparkEmitter)) {
    part_emitter_destroy(obj_particleIndex.fireSpark, fireSparkEmitter);
}

// Destroy sound emitter
if (!audio_emitter_exists(s_emit)) {
    audio_emitter_free(s_emit);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sound checks and emitter pos update
// First check that audio emitter exists, if not, recreate it
if (!audio_emitter_exists(s_emit)) {
    s_emit = audio_emitter_create();
}
// Update pos
audio_emitter_position(s_emit, x, y, 0);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// do entity funcs
/* This is responsible for doing all functions
 * associated with an entity
*/

if (round(xPush) != 0 || round(yPush) != 0) {
    var newX = (x + power(xPush, global.timeScale));
    var newY = (y + power(yPush, global.timeScale));
    
    // Calculate bounce off collisions from push
    /* Note if you want the entity to bounce,
     * make xPush and ypush = -xpush and -ypush (reversing the
     * push and effectivly bouncing off the wall
    */
    // Bounce
    /*
    if (place_meeting(newX, y, obj_collision)) {
        xPush = -xPush; // flip x push (bounce off collision)
    }
    
    if (place_meeting(x, newY, obj_collision)) {
        yPush = -yPush; // flip x push (bounce off collision)
    }
    */
    if (place_meeting(newX, y, obj_collision)) {
        xPush = 0; // stop x movement (hit collision)
    }
    // add push forces to x of entity (horizontal movement)
    // force calculations separated to prevent getting stuck in corner collisions
    x += xPush;
    xPush *= power(pushResist, global.timeScale); // resist the force over time, slowly down for example
    
    if (place_meeting(x, newY, obj_collision)) {
        yPush = 0; // stop y movement (hit collision)
    }
    // add push forces to y of entity (vertical movement)
    y += yPush;
    yPush *= power(pushResist, global.timeScale); // resist the force over time, slowly down for example
    
    /* If a zombie, their pathfinding path
     * must be ended in order to affect their
     * x and y vals
    */
    if (object_index == obj_zombie || object_index == obj_civilian) {
        path_end();
    }
}

if (isHurt) {
    if (hurtTimer &gt;= 0) {
        hurtTimer -= 1 * global.timeScale;
    }
    else {
        hurtTimer = hurtTime;
        isHurt = false;
    }
}

// If on fire and not already on fire
if (place_meeting(x, y, obj_fire) &amp;&amp; !isOnFire) {
    isOnFire = true;
    hurtTimer = 0;
    // have fireLight parented to entity
    fireLight = instance_create(x, y, obj_light);
    
    fireTimer = fireTime;
    
    with (fireLight) {
        parent = other.id;
        radius = 128;
        orgRadius = 128;
        flicker = true;
        color = c_orange;
    }
}

// If entity was lit on fire and hurt timer interval finished, hurt entity again
if (isOnFire &amp;&amp; hurtTimer &lt;= 0) {
    // If emitter already exists, burst particle
    if (part_emitter_exists(obj_particleIndex.fireSpark, fireSparkEmitter)) {
        part_emitter_region(obj_particleIndex.fireSpark, fireSparkEmitter, x - 5, x + 5, y - 5, y + 5, ps_shape_ellipse, ps_distr_linear); 
        part_emitter_burst(obj_particleIndex.fireSpark, fireSparkEmitter, obj_particleIndex.fireSpark, 2);
    }
    else {
        // Init fire spark particle
        fireSparkEmitter = part_emitter_create(obj_particleIndex.fireSpark);
    }
    scr_hurt(id, 1); // constant hurts
    hurtTimer = room_speed; // 1 second delay between each hurt
}
// If on fire, keep counting down the fireTimer
if (isOnFire) {
    if (fireTimer &gt; 0) {
        fireTimer --;
    }
    else {
        // Make entity no longer on fire
        isOnFire = false;
    }
}

// If no longer or not on fire, destroy fireSpark emitter if it exists
if (!isOnFire) {
    if (part_emitter_exists(obj_particleIndex.fireSpark, fireSparkEmitter)) {
        part_emitter_destroy(obj_particleIndex.fireSpark, fireSparkEmitter);
    }
    with (fireLight) {
        instance_destroy();
    }
    fireLight = noone; // reset firelight variable
}

// If entity is discovered dead, make it dead
if (hp &lt;= 0) {
    isDead = true;
    
    // Make all entities no longer target this one
    scr_removeOtherEntityTargeting();
    
    // Do not destroy player object if hp of entity is 0
    switch (object_index) {
        case obj_player:
            // If player
            // create blood pool
            instance_create(x, y, obj_bloodPool);
        break;
        case obj_civilian:
            // end path, destroy self (which creates the dead body in destroy event)
            path_end();
            instance_destroy();
            instance_create(x, y, obj_bloodPool);
        break;
        default:
            instance_destroy();
    }
}

// character sitting on something (chair)
if (interactEntity != noone) {
    x = interactEntity.x;
    y = interactEntity.y;
}

depth = scr_getDepth(y, 0, true);


// prevent entity from leaving the room
if (x &lt; 0) {
    x = 0;
    xPush = 0;
}
if (x &gt; room_height) {
    x = room_height;
    xPush = 0;
}
if (y &lt; 0) {
    y = 0;
    yPush = 0;
}
if (y &gt; room_height) {
    y = room_height;
    yPush = 0;
}

// Use replacement img_index and img_speed and img_number
// for more info on why I use this look at:
// scr_initEntityVars()
img_index += img_speed * global.timeScale;
if (img_index &gt; img_number) {
    img_index = 0;
}
// Make img_speed and image speed both go off timescale
//img_speed = img_speed * global.timeScale;
image_speed = image_speed * global.timeScale;

var bobHeight = 0.15; //def 0.15
var movementAmt;
if (object_index == obj_zombie || object_index == obj_civilian) {
    movementAmt = path_speed;
}
else if (object_index == obj_heavyZombie) {
    // Make big zombie slam down when bobbing down (showing lots of weight)
    if (isBobbingUp) {
        movementAmt = path_speed;
    }
    else {
        movementAmt = path_speed * 5;
    }
    bobHeight = 0.25;
}
else {
   movementAmt = sqrt(sqr(abs(x - xprevious)) + sqr(abs(y - yprevious))); 
}

if (isBobbingUp) {
    bobbing = clamp(bobbing + (movementAmt / 16), 0, 1);
}
else {
    bobbing = clamp(bobbing - (movementAmt / 16), 0, 1);
}

drawScale = 1 + (bobbing * bobHeight);

// At top of bob, begin shrinking down
if (bobbing == 1) {
    isBobbingUp = false;
}
// At bottom of bob, begin enlarging up, play footstep sound effect
else if (bobbing == 0 &amp;&amp; !isBobbingUp) {
    isBobbingUp = true;
    switch (object_index) {
        case obj_player:
        case obj_zombie:
            audio_play_sound_on(s_emit, choose(snd_footsteps_generic_1, snd_footsteps_generic_2, 
                                                snd_footsteps_generic_3, snd_footsteps_generic_4), 
                                                false, 5);
        break;
    }
}

// Hide character if in vehicle
if (object_is_ancestor(interactEntity.object_index, obj_vehicleP)) {
    visible = false;
}
else {
    visible = true;
}

// Audio emitter position update

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
