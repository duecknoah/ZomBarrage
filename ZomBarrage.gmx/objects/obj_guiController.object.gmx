<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(fnt_normal);
show_debug_message(object_get_name(object_index) + " created");

// Game gui settings
guiScale = 4;
/* GUI variables ************
* The difference from having an alpha of 0 and having for example showWaveBarGui equal to
* false is that having showWaveBarGui set to false makes it not run any code to do with
* the wave bar.
*   ex. Checking if a button is pressed on the wave bar (if there was one)
*   if the user is clicking on the gui button
*/
showUpgradeScreen = false; // show upgrade screen?
showUpgradeButton = true; // show the button at the top left to access the upgrades?
showPauseScreen = false; // show pause gui?
showPauseButton = true; // show the button at the top right to access the pause screen?
showWeaponPickupText = false; // show weapon pickup text?
showWeaponScope = false; // show weapon scope?
showWaveBar = true; // show the wave bar?
showWaveCompletionScreen = true; // show the wave completed screen?
showOnFireGuiAlpha = true; // run the code to do with the on fire on the screen?
showInventory = true; // Weapon slots and inventory
showHealthBar = true;
showRespawnScreen = false; // is shown once player dies
showLootingBar = true; // show the loading like bar when looting
showLootingChooseScreen = true; // show the screen post-looting of where the player chooses what they want from the looting
showChatBar = false; // show all the chatbar items? (the bottom bar where dialogue shows)
// Other gui variables
shootDelayMax[0] = 0; // stores the highest value when shootdelay[0] of player is not 0
shootDelayMax[1] = 0; // stores the highest value when shootdelay of player is not 0
// Gui variable alpha
upgradeScreenAlpha = 1;
upgradeButtonAlpha = 1;
pauseScreenAlpha = 0.5;
pauseButtonAlpha = 1;
waveBarGuiAlpha = 1;
waveCompletionScreenAlpha = 1;
weaponScopeAlpha = 1;
weaponPickupTextAlpha = 1;
OnFireGuiAlpha = 0; // when player is on fire, this will increase
inventoryAlpha = 1;
healthBarAlpha = 1;
lootingBarAlpha = 1;
lootingChooseScreenAlpha = 1;
chatBarAlpha = 1;
// Cutscene
showForegroundImage = false; // show foreground image?
foregroundImage = noone;
foregroundImageAlpha = 0; // 1=nothing shown but foreground image, 0=foreground image not shown, everything else shown, 0-1)
// Other Chatbar variables
    // each index holds the next string of text in the dialogue, 
    // ex. (0="Hello, how are you?", 1="I'm good!"), this is where 
    // you can insert your dialogue into and it should automatically work
    chatBarMessage = ds_list_create();
    chatBarMessageDisplayed = ""; // the current message displayed in the chatbar
    // the image of the current speaker, corresponds with the 
    // indexs within chatBarMessage so the 
    // speaker shown goes with the correct message
    chatBarSpeakerSprite = ds_list_create(); // the sprite 
    chatBarSpeakerSubimg = ds_list_create(); // the subimage within the sprite
    chatBarWidth = 960;
    chatBarHeight = 128;
    chatBarPadding = 16;
    chatBarPaddingSpeaker = 192; // padding on the right for the speaker
    // the line we are on within chatBarMessageDisplayed, 
    // a new line is created when the text no longer fits on the page
    chatBarCurrentMessageLineNumber = 0; // the current line number within the message string
    chatBarCurrentCharPos = 0; // current character number within the message string
    chatBarStart = ds_list_create(); // stores the starting line numbers for the current message displayed
    chatBarLastSpacePos = -1; // the position in the message string of the last space
    chatBarTimer = 0;
// Console
consoleSurf = surface_create(750, 500); // surface used for console drawing
showConsole = false; // can be toggled in debug mode
outputConsoleString = ""; // console string of previously typed things
inputConsoleString = ""; // current typed console string
consoleHelpDB = ds_list_create(); // console help list dataBase
consoleLineOffset = 0; // 0 - n, where n is the last line in the console outputConsoleString
                       // scrolling affects this number when in the console
scr_initConsoleDB();

scr_consoleOutPrintln("Console: Type 'help' for help.");
scr_consoleOutPrintln("Press 'TAB' to close");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy consoleHelpDB ds list, free mem
if (ds_exists(consoleHelpDB, ds_type_list)) {
    ds_list_destroy(consoleHelpDB);
}

// Free console surface from mem
if (surface_exists(consoleSurf)) {
    surface_free(consoleSurf);
}

// Chatbar
if (ds_exists(chatBarMessage, ds_type_list)) {
    ds_list_destroy(chatBarMessage);
}
if (ds_exists(chatBarSpeakerSprite, ds_type_list)) {
    ds_list_destroy(chatBarSpeakerSprite);
}
if (ds_exists(chatBarSpeakerSubimg, ds_type_list)) {
    ds_list_destroy(chatBarSpeakerSubimg);
}
if (ds_exists(chatBarStart, ds_type_list)) {
    ds_list_destroy(chatBarStart);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// gui
// Main temp Vars
var centerX = view_wport[0] / 2;
var centerY = view_hport[0] / 2;
display_set_gui_size(view_wport[0], view_hport[0]);

//////////////////////////
// When game over, fade out game gui and fade in stats
if (obj_player.isDead) {
    showRespawnScreen = true;
}
var onFireFadeSpd = 0.01;
if (obj_player.isOnFire) {
    if (OnFireGuiAlpha &lt; 1) {
        OnFireGuiAlpha += onFireFadeSpd;
    }
}
else {
    if (OnFireGuiAlpha &gt; 0) {
        OnFireGuiAlpha -= onFireFadeSpd;
    }
}
// on Fire gui
if (showOnFireGuiAlpha) {
    draw_sprite_ext(spr_onFireGui, 0, 0, 0, 10, 10, 0, c_white, OnFireGuiAlpha);
}

// Game gui
// Sniper rifle scope
if (obj_player.state == "Sniper Rifle scoped" || obj_player.state == "Sniper Rifle scoped shoot") {
    showWeaponScope = true;
}
else {
    showWeaponScope = false;
}

if (showWeaponScope) {
// draw zoomed in portion from default application surface
    var xSize = 128;
    var ySize = 128;
    var scale = 2;
    /* NOTE 1: We draw the application surface twice as the shadow tiles
     * seem to be slightly transparent for some odd reason. So
     * to counter this, we draw the application surface several
     * times to cancel out the alpha
     * NOTE 2: We have a sniperScopeLight used in obj_player's player state
     * manager (scr_PlayerStateManager()), this light follows the mouse_x and
     * mousey under the scope, giving the player a lit up view. It also allows
     * the application surface to pre-draw that area just before the below code
     * is executed, if this is not done, any area attempted to draw that isn't
     * effected by a light doesn't get drawn. Not sure why :(
     */
    for(var i = 0; i &lt; 2; i ++) {
    draw_surface_part_ext(application_surface, 
                            device_mouse_x_to_gui(0) - (xSize / 2), 
                            device_mouse_y_to_gui(0) - (ySize / 2), 
                            xSize, 
                            ySize, 
                            device_mouse_x_to_gui(0) - (xSize * scale / 2), 
                            device_mouse_y_to_gui(0) - (ySize * scale / 2), 
                            scale, 
                            scale, 
                            c_white,
                            weaponScopeAlpha);
    }
    draw_sprite_ext(spr_sniperRifleScope, 0, device_mouse_x_to_gui(0), device_mouse_y_to_gui(0), guiScale, guiScale, 0, c_white, weaponScopeAlpha);
}

// Draw WaveBar
if (showWaveBar) {
    var text = "";
    var yy = sprite_get_height(spr_WaveBar) * guiScale / 2;
    
    draw_sprite_ext(spr_WaveBar, 0, centerX, yy, guiScale, guiScale, 0, c_white, waveBarGuiAlpha);
    
    text += "Wave " + string(global.currentWave);
    
    if (global.delayBetweenWavesTimer &gt;= 0) {
        text += "   Next Wave: " + string(global.delayBetweenWavesTimer);
    }
    
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_set_colour(c_white);
    draw_set_alpha(waveBarGuiAlpha);
    draw_text(centerX, yy, text);
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
}

// Draw Upgrade button
if (showUpgradeButton) {
    var text = "";
    var xx = centerX / 2 - (sprite_get_width(spr_upgradeBar) * guiScale / 2);
    var yy = 0;
    
    if (scr_buttonGuiSpriteText(xx, yy, spr_upgradeBar, guiScale, "UPGRADES", c_white, upgradeButtonAlpha) == 2
    || keyboard_check_pressed(vk_tab)) {
        // Toggle upgrades if button pressed
        if (showUpgradeScreen) {
            showUpgradeScreen = false;
            // Put timescale back to normal
            scr_setTimeScale(1);
            mouse_clear(mb_any);
        }
        else {
            showUpgradeScreen = true;
            // Make global.timeScale slower when accessing upgrades (so player doesn't just die right away
            scr_setTimeScale(0.05);
            mouse_clear(mb_any); // prevent user from accidently buying something instantly
        }
    }
}

// Draw Pause Button
if (showPauseButton) {
    xx = centerX + (centerX / 2) + (sprite_get_width(spr_upgradeBar) * guiScale / 2);
    yy = 0;
    if (scr_buttonGuiSpriteText(xx, yy, spr_upgradeBar, guiScale, "PAUSE", c_white, pauseButtonAlpha) == 2
    || keyboard_check_pressed(vk_escape)) {
        // Toggle pausing
        if (!showPauseScreen) {
            scr_setTimeScale(0);
            showPauseScreen = true;
        }
        else {
            scr_setTimeScale(1);
            showPauseScreen = false;
        }
    }
}

// Wave completion screen checking
var durOfText = 3; // maximum duration to show text in seconds
if (global.waveCompleted &amp;&amp; global.delayBetweenWaves - global.delayBetweenWavesTimer &lt; durOfText) {
    showWaveCompletionScreen = true;
}
else {
    showWaveCompletionScreen = false;
}

// Wave completed text / screen
if (showWaveCompletionScreen) {
    draw_set_alpha(waveCompletionScreenAlpha);
    draw_text(centerX, centerY, "Wave Completed!");
    draw_set_alpha(1);
}

// Draw inventory GUI
if (showInventory) {
    scr_drawInventoryGui(0,
                        view_hport[0] - (sprite_get_height(spr_inventory) / 2 * guiScale),
                        guiScale,
                        inventoryAlpha);
}

// Re setup ds_lists (dynamic variables) if they don't exist
if (!ds_exists(chatBarStart, ds_type_list)) {
    chatBarStart = ds_list_create();
}
if (!ds_exists(chatBarSpeakerSprite, ds_type_list)) {
    chatBarSpeakerSprite = ds_list_create();
}
if (!ds_exists(chatBarSpeakerSubimg, ds_type_list)) {
    chatBarSpeakerSubimg = ds_list_create();
}
if (!ds_exists(chatBarMessage, ds_type_list)) {
    chatBarMessage = ds_list_create();
}

// If there is message data for chatbar
if (!ds_list_empty(chatBarMessage)) {
    showChatBar = true; // show it
}
else {
    showChatBar = false; // else hide it
}

// Chat bar
if (showChatBar) {
    // As we go through each message, once
    // the user skips on to the next dialogue
    // line, we remove index 0 (the first message)
    // and naturally the next message will fall into
    // index 0, continully doing this until there are
    // no more messages and thats where we hide the chatbar
    //ds_list (chatBarMessage)
    var chatBarX = 256;
    var chatBarY = view_hport[0] - chatBarHeight;
    var instantShowMessage = false; // instantly finish printing message to screen? true when player presses chatBarSkipMessageButton
    
    if (keyboard_check_pressed(obj_controls.chatBarSkipMessageButton)) {
        // First check if the full message has been shown, if so. Allow user to skip to next message in the ds_list
        if (chatBarCurrentCharPos == string_length(chatBarMessage[| 0])) {
            // Delete the current messages, the next messages will
            // fall into index 0 (if there is more)
            ds_list_delete(chatBarMessage, 0);
            ds_list_delete(chatBarSpeakerSprite, 0);
            ds_list_delete(chatBarSpeakerSubimg, 0);
            ds_list_clear(chatBarStart); // clears all the starting numbers for the message displayed
            // Reset vars
            chatBarMessageDisplayed = "";
            chatBarLastSpacePos = -1;
            chatBarCurrentCharPos = 0;
            chatBarCurrentLineNumber = 0;
            chatBarCurrentMessageLineNumber = 0;
        }
        else {
        // Else if message isn't fully shown yet (still printing out to screen, instantly finish sentence.
            instantShowMessage = true;
        }
    }

    // If there is no start line entries, set it to 0
    if (ds_list_empty(chatBarStart)) {
        ds_list_add(chatBarStart, 0);  
    }
    
    // Do loop for instantly instantShowMessage    
    do {
        // Auto Line breaking
        if (string_width(chatBarMessageDisplayed) &gt; chatBarWidth - chatBarPadding - chatBarPadding - chatBarPaddingSpeaker) {
            chatBarMessageDisplayed = string_delete(chatBarMessageDisplayed, chatBarLastSpace, 1);
            chatBarMessageDisplayed = string_insert("#", chatBarMessageDisplayed, chatBarLastSpace);
            ds_list_add(chatBarStart, chatBarLastSpace + 1); // add the next line number
        }
        
        if (chatBarTimer &lt;= 0) {
            // If not at end of string yet
            if (chatBarCurrentCharPos &lt; string_length(chatBarMessage[| 0])) {
                // Add the next character to the display string
                var nextChar = string_char_at(chatBarMessage[| 0], chatBarCurrentCharPos + 1);
                
                // Check if it is a space
                if (nextChar == " ") {
                    // If so, mark this position as the last space
                    chatBarLastSpace = chatBarCurrentCharPos + 1;
                }
                chatBarMessageDisplayed += nextChar;
                chatBarTimer = 2; // reset timer, the lower the number, the faster the text goes
                chatBarCurrentCharPos ++; // move the position forward one
            }
        }
        else {
        // keep counting down the timer
            chatBarTimer --;
        }   
        
        var finalStr = "";
        
        if (chatBarMessageDisplayed != "") {
            var index = ds_list_find_value(chatBarStart, chatBarCurrentMessageLineNumber);
            var count = chatBarCurrentCharPos - ds_list_find_value(chatBarStart, chatBarCurrentMessageLineNumber);
            
            finalStr = string_copy(chatBarMessageDisplayed, index, count);
        }
        
        // Did we go past the bottom? move up a line
        if (string_height(finalStr) &gt; chatBarHeight - chatBarPadding) {
            chatBarCurrentMessageLineNumber ++;
        }
    } until ((instantShowMessage == true &amp;&amp; chatBarCurrentCharPos == string_length(chatBarMessage[| 0])) || (instantShowMessage == false));
    // If not instantShowMessage, don't loop. Else loop until it went through the entire message
    
    // Draw the background box!
    draw_set_color(c_dkgray);
    draw_rectangle(chatBarX, chatBarY, chatBarX + chatBarWidth, chatBarY + chatBarHeight, 0);
    // Draw the text!
    draw_set_color(c_white);
    draw_text(chatBarX + chatBarPadding, chatBarY + chatBarPadding, finalStr);
    // Draw the speaker!
    draw_sprite_ext(chatBarSpeakerSprite[| 0], chatBarSpeakerSubimg[| 0], 1025, 529, guiScale, guiScale, 0, c_white, 1);
    
    // toggle healthbar based on if chatbar is showing or not
    if (!ds_list_empty(chatBarMessage)) {
        showHealthBar = false; // hide health bar
    }
    else {
        showHealthBar = true;
    }
} 

// Draw HealthBar Gui
if (showHealthBar) {
    var hbx = centerX - ((sprite_get_width(spr_healthBar) / 2) * guiScale);
    var hby = view_hport[0] - (sprite_get_height(spr_healthBar) * guiScale);
    var hbHealthMaxXScale = guiScale;
    var hbHealthPerc = obj_player.hp / obj_player.maxHp;
    var hbHealthXScale = lerp(0, hbHealthMaxXScale, hbHealthPerc);
    
    // Healthbar background (behind red health)
    draw_sprite_ext(spr_healthBar, 2, hbx, hby, guiScale, guiScale, 0, c_white, healthBarAlpha);
    // Healthbar health (red)
    draw_sprite_ext(spr_healthBar, 1, hbx, hby, hbHealthXScale, guiScale, 0, c_white, healthBarAlpha);
    // Healthbar frame
    draw_sprite_ext(spr_healthBar, 0, hbx, hby, guiScale, guiScale, 0, c_white, healthBarAlpha);
}

// Weapon pickup text toggling
with (obj_player) {
    if (place_meeting(x, y, obj_itemWeapon)) {
        other.showWeaponPickupText = true;
    }
    else {
        other.showWeaponPickupText = false;
    }   
}
// Weapon pickup text
if (showWeaponPickupText) {
    var weaponInst;
    with (obj_player) {
        weaponInst = instance_place(x, y, obj_itemWeapon);
    }
    draw_set_alpha(weaponPickupTextAlpha);
    draw_text(view_wport[0] / 2, view_hport[0] / 2 + 256, "'E' to pickup " + weaponInst.weaponType);
    draw_set_alpha(1);
}

// Looting bar
if (obj_player.state == "looting") {
    showLootingBar = true;
}
else {
    showLootingBar = false;
}

if (showLootingBar) {
    var lbx = centerX;
    var lby = centerY;
    draw_sprite_ext(spr_lootingBar, 0, lbx, lby, guiScale, guiScale, 0, c_white, lootingBarAlpha);
    // Draw progress bar
    var lbProgressX1 = lbx - ((sprite_get_width(spr_lootingBar) / 2) * guiScale) + (7 * guiScale);
    var lbProgressY1 = lby - ((sprite_get_height(spr_lootingBar) / 2) * guiScale) + (4 * guiScale);
    var lbProgressX2 = lbx - ((sprite_get_width(spr_lootingBar) / 2) * guiScale) + (89 * guiScale);
    var lbProgressY2 = lby - ((sprite_get_height(spr_lootingBar) / 2) * guiScale) + (11 * guiScale);
    var lootPerc = 1 - (obj_player.lootTimer / obj_player.lootTime);
    
    var lbProgressX2 = lerp(lbProgressX1, lbProgressX2, lootPerc);
    
    draw_set_colour(c_yellow);
    draw_set_alpha(lootingBarAlpha);
    draw_rectangle(lbProgressX1, lbProgressY1, lbProgressX2, lbProgressY2, 0);
    draw_set_alpha(1);
    draw_set_colour(c_white);
}

// Looting choose gui
if (obj_player.state == "loot choose") {
    showLootingChooseScreen = true;
}
else {
    showLootingChooseScreen = false;
}

if (showLootingChooseScreen) {
    // Darken background
    draw_set_alpha(0.5);
    draw_set_colour(c_black);
    draw_rectangle(0, 0, view_wport[0], view_hport[0], 0);
    draw_set_colour(c_white); // reset
    draw_set_alpha(lootingChooseScreenAlpha); // reset
    
    var yy = view_hport[0] / 2;
    
    // Draw current inventory GUI
    scr_drawInventoryGui(256,
                    yy,
                    guiScale,
                    lootingChooseScreenAlpha);
    // Draw loot area gui
    scr_drawAreaLootGui(view_wport[0] / 2, 
                    yy - 64, 
                    obj_player.lootArea, 
                    guiScale, 
                    lootingChooseScreenAlpha);
}

// Draw upgrade screen if alpha &gt; 0 and showing upgrades and not game over
if (showUpgradeScreen) {
    /* Things that can be upgraded:
     * - player max hp
     * - player overall shot accuracy
     * - player lootRank
     * - player lootRange
    */
    // Draw background
    var bx = centerX - (sprite_get_width(spr_upgradeBackground) * guiScale / 2);
    var by = centerY - (sprite_get_height(spr_upgradeBackground) * guiScale / 2);
    draw_sprite_ext(spr_upgradeBackground, 0, bx, by, guiScale, guiScale, 0, c_white, upgradeScreenAlpha);
    
    // Upgrade buttons
    var xx = bx;
    var yy = by;
    var yOff = sprite_get_height(spr_upgradeButton) * guiScale + 4;
   /* ex. upgrade button:
    *   if (scr_buttonGuiUpgrade(xx, yy, spr_upgradeBar, "This is a test upgrade.", 1, guiScale)) {
    *       room_restart();
    *   }
   */
   if (scr_buttonGuiUpgrade(xx, yy, 
                            "TEMP_NO_SPRITE", 
                            "Increase max health of yourself by 10#Current: " + string(obj_player.maxHp),
                            2 * obj_player.maxHp,
                            guiScale, upgradeScreenAlpha)) {
        obj_player.maxHp += 10;
        obj_player.hp = obj_player.maxHp;
   }
   yy += yOff;
   if (scr_buttonGuiUpgrade(xx, yy, 
                            "TEMP_NO_SPRITE", 
                            "Increase your lootrank.#Current: " + string(obj_player.lootRank), 
                            10 * obj_player.lootRank + 5, 
                            guiScale, upgradeScreenAlpha)) {
        obj_player.lootRank ++;
   }
   yy += yOff;
   if (scr_buttonGuiUpgrade(xx, yy, 
                           "TEMP_NO_SPRITE",
                           "Increase your average shot accuracy.#Current: +" + string((1 - obj_player.shotAcc) * 100) + "%", 
                           10 * obj_player.shotAcc + 5, 
                           guiScale, upgradeScreenAlpha)) {
        obj_player.shotAcc /= 1.5;
   }
   yy += yOff;
   if (scr_buttonGuiUpgrade(xx, yy, 
                           "TEMP_NO_SPRITE",
                           "Increase your explosive damage by 5.#Current: +" + string(obj_player.exploDmg), 
                           10 * obj_player.exploDmg + 5, 
                           guiScale, upgradeScreenAlpha)) {
        obj_player.exploDmg += 5;
   }
   yy += yOff;
   if (scr_buttonGuiUpgrade(xx, yy, 
                           "TEMP_NO_SPRITE",
                           "Increase your bullet damage by 5.#Current: +" + string(obj_player.bulletDmg), 
                           10 * obj_player.bulletDmg + 5, 
                           guiScale, upgradeScreenAlpha)) {
        obj_player.bulletDmg += 5;
   }
   yy += yOff;
}

// Pause Screen
if (showPauseScreen) {
    // Fade in background alpha based of global.timeScale fade out speed
    var _backgroundAlpha = lerp(0, 0.5, 1 - global.timeScale);
    _backgroundAlpha -= pauseScreenAlpha;
    
    // Background col
    draw_set_colour(c_black);
    draw_set_alpha(_backgroundAlpha);
    draw_rectangle(0, 0, view_wport[0], view_hport[0], 0);
    draw_set_alpha(1);
    
    // Pause Text
    draw_set_colour(c_white);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_set_alpha(pauseScreenAlpha);
    draw_text(centerX, centerY, "PAUSED");
    draw_text(centerX, centerY + 128, "Press 'ESC' To Resume");
    draw_set_alpha(1);
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
}

// Cutscene round image gui
if (showForegroundImage) {
    if (foregroundImage != noone) {
        var w = sprite_get_width(foregroundImage);
        var h = sprite_get_height(foregroundImage);
        var stretchedW = view_wport[0] / w;
        var stretchedH = view_hport[0] / h;
        
        draw_sprite_ext(foregroundImage, 0, 0, 0, stretchedW, stretchedH, 0, c_white, foregroundImageAlpha);
    }
}

// gui object text drawing
for (i = 0; i &lt; instance_number(obj_guiText); i += 1) {
        var guiText = instance_find(obj_guiText, i);
        draw_set_font(guiText.font);
        draw_set_halign(guiText.textHAlign);
        draw_set_valign(guiText.textVAlign);
        draw_set_alpha(guiText.textAlpha);
        draw_set_color(guiText.textCol);
        draw_text(guiText.textX, guiText.textY, guiText.text);
}
// reset
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_alpha(1);
draw_set_color(c_white);

// If in debug mode, show framerate
if (debug_mode) {
    var _y = 16;
    draw_text(16, _y, "FPS real: " + string(fps_real));
    _y += 16;
    draw_text(16, _y, "view_xview: " + string(view_xview[0]));
    _y += 16;
    draw_text(16, _y, "view_yview: " + string(view_yview[0]));
    _y += 16;
    draw_text(16, _y, "view_wview: " + string(view_wview[0]));
    _y += 16;
    draw_text(16, _y, "view_hview: " + string(view_hview[0]));
    _y += 16;
    draw_text(device_mouse_x_to_gui(0), device_mouse_y_to_gui(0) - 16, string(device_mouse_x_to_gui(0)) + " " + string(device_mouse_y_to_gui(0)));
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Debug console

if (debug_mode) {
    // Toggle console
    if (keyboard_check_pressed(vk_anykey)) {
        if (keyboard_key == 192 || keyboard_key == 223) {
            if (showConsole) {
                showConsole = false;
            }
            else {
                showConsole = true;
            }
            if (string_length(keyboard_string) &gt; 0) {
                var tildePos = string_pos('`', keyboard_string);
                if (tildePos != -1) {
                    keyboard_string = string_delete(keyboard_string, tildePos, 1);
                }
            }
        }
    }
    
    if (showConsole) {
        // Re-create surface if it doesn't exist
        if (!surface_exists(consoleSurf)) {
            consoleSurf = surface_create(750, 500);
            exit; // prevent further code from running here
        }
        surface_set_target(consoleSurf);
        draw_clear_alpha(c_black, 0.5); // clear surface from last draw
        
        var consoleX = 0;
        var consoleY = 0;
        var showCursor = false; // show console cursor in this step?
        var cursorBlinkRate = room_speed / 2;

        if ((current_time / 10) % room_speed &lt; cursorBlinkRate) {
            showCursor = true;
        }
        
        // Scrolling in console
        if (mouse_wheel_up()) {
            // lower consoleLineOffset
            var lineCount = string_count("#", outputConsoleString);
            consoleLineOffset = clamp(consoleLineOffset - 1, 1, lineCount);
        }
        
        if (mouse_wheel_down()) {
            // raise consoleLineOffset
            var lineCount = string_count("#", outputConsoleString);
            consoleLineOffset = clamp(consoleLineOffset + 1, 1, lineCount);
        }
        
        draw_set_halign(fa_left);
        draw_set_valign(fa_top);
        draw_set_colour(c_white);
        // previous console string below where user types into console in
        
        // Offset the text by &lt;consoleLineOffset&gt; lines (affected by scrolling in console)
        var lineCount, oneLineH, totalOffset;
        lineCount = string_count("#", outputConsoleString);
        if (lineCount &gt; 0) {
            oneLineH = string_height_ext(outputConsoleString, -1, -1) / lineCount;
            totalOffset = oneLineH * consoleLineOffset; 
        }
        else {
            totalOffset = 0;
        }
        
        // Console output
        //draw_text(consoleX, consoleY - totalOffset, "###" + outputConsoleString);
        draw_text_ext(consoleX, consoleY - totalOffset, "###" + outputConsoleString, -1, surface_get_width(consoleSurf));
        // Console input
        draw_set_alpha(0.5);
        draw_set_colour(c_black);
        draw_rectangle(0, 0, surface_get_width(consoleSurf), surface_get_height(consoleSurf), 0); // clear surface from last draw
        draw_set_alpha(1);
        draw_set_colour(c_white);
        if (showCursor) {
            draw_text(consoleX, consoleY, inputConsoleString + '| ');
        }
        else {
            draw_text(consoleX, consoleY, inputConsoleString);
        }
        draw_set_halign(fa_left);
        draw_set_valign(fa_top);
        // Draw console surface
        surface_reset_target();
        draw_surface(consoleSurf, view_wport[0] / 4, 128);
        
        // Console input
        var input, isNoInput;
        input = scr_consoleGetInput();
        if (input != -1) {
            isNoInput = ds_list_empty(input);
            
            // Console function running
            // If there is input
           // if (!isNoInput) {
            // If there is a typed string
            // Execute the input
            scr_consoleRunFunc(input);
            ds_list_destroy(input); // free RAM
           // }
        }
        scr_consoleKeyFuncs();
    }
    else { // if not showing console
        keyboard_string = "";
        inputConsoleString = "";
    }
}
else { // if not in debug mode
    showConsole = false; // turn off showConsole
    /* this is done to prevent other objects in the
     * game (like obj_player) from thinking the console
     * is shown, when it can't be when not in debug_mode.
    */
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
